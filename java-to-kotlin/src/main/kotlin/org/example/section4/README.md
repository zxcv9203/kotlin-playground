# 코틀린에서 배열과 컬렉션을 다루는 방법

- Java와 Kotlin 코드를 섞어 컬렉션을 사용할 때에는 주의해야 합니다.
  - Java에서 Kotlin 컬렉션을 가져갈 때는 불변 컬렉션을 수정할 수도 있고, non-nullable 컬렉션에 null을 넣을 수도 있습니다.
  - Kotlin에서 Java 컬렉션을 가져갈 때는 플랫폼타입을 주의해야 합니다.

# 코틀린에서 다양한 함수를 다루는 방법
- Java 코드가 있는 상황에서, Kotlin 코드로 추가 기능 개발을 하기 위해 확장함수와 확장 프로퍼티가 등장했습니다.
- 확장함수는 원본 클래스의 private, protected 멤버 접근이 안됩니다.
- 멤버함수, 확장함수 중 멤버 함수에 우선권이 있습니다.
- 확장함수는 현재 타입을 기준으로 호출됩니다.
- Java에서는 static 함수를 쓰는 것 처럼 Kotlin의 확장함수를 쓸 수 있습니다.
- 함수 호출 방식을 바꿔주는 infix 함수가 존재합니다.
- 함수를 복사 붙여넣기 하는 inline 함수가 존재합니다.
- Kotlin에서는 함수 안에 함수를 선언할 수 있고, 지역함수라고 부릅니다.

# 코틀린에서 람다를 다루는 방법
- 함수는 Java에서 2급시민이지만, 코틀린에서는 1급시민입니다.
  - 때문에, 함수 자체를 변수에 넣을 수도 있고 파라미터로 전달할 수도 있습니다.
- 코틀린에서 함수 타입은 (파라미터 타입, ...) -> 반환 타입으로 사용됩니다.
- 함수를 호출하며, 마지막 파라미터인 람다를 쓸 때는 소괄호 밖으로 람다를 뺄 수 있습니다.
  ```kotlin
    fun main() {
        val result = callByLambda(3, 7) { a, b -> a + b }
        println(result)
    }
   ```
- 람다의 마지막 expression 결과는 람다의 반환 값입니다.
- 코틀린에서는 Closure를 사용하여 non-final 변수도 람다에서 사용할 수 있습니다.